package dev.tenacity.module.impl.exploit;

import com.cubk.event.annotations.EventTarget;
import com.cubk.event.impl.game.WorldEvent;
import com.cubk.event.impl.network.PacketReceiveEvent;
import com.cubk.event.impl.network.PacketSendEvent;
import com.cubk.event.impl.player.MotionEvent;
import com.cubk.event.impl.player.MoveEvent;
import com.cubk.event.impl.player.UpdateEvent;
import dev.tenacity.Client;
import dev.tenacity.module.Category;
import dev.tenacity.module.Module;
import dev.tenacity.module.impl.movement.Speed;
import dev.tenacity.module.settings.impl.BooleanSetting;
import dev.tenacity.module.settings.impl.ModeSetting;
import dev.tenacity.module.settings.impl.MultipleBoolSetting;
import dev.tenacity.module.settings.impl.NumberSetting;
import dev.tenacity.ui.notifications.NotificationManager;
import dev.tenacity.ui.notifications.NotificationType;
import dev.tenacity.utils.Utils;
import dev.tenacity.utils.misc.MathUtils;
import dev.tenacity.utils.player.ChatUtil;
import dev.tenacity.utils.server.PacketUtils;
import dev.tenacity.utils.server.ServerUtils;
import dev.tenacity.utils.time.TimerUtil;
import lombok.Getter;
import net.minecraft.client.entity.EntityPlayerSP;
import net.minecraft.network.Packet;
import net.minecraft.network.play.INetHandlerPlayClient;
import net.minecraft.network.play.client.*;
import net.minecraft.network.play.server.*;
import net.minecraft.potion.Potion;
import net.minecraft.util.AxisAlignedBB;

import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.stream.Collectors;

public final class Disabler extends Module {
    private final ModeSetting disMode = new ModeSetting("Dis", "SW", "BW", "SW"); // 模式选择（SkyWars 或 BedWars）
    private final BooleanSetting modifyRotationValue = new BooleanSetting("EditRotation", false);
    private final BooleanSetting lobbyCheck = new BooleanSetting("LobbyCheck", false); // 是否检查大厅
    @Getter
    public boolean disabling;
    @Getter
    public int s08PacketTickCount;
    private int airTicks;
    private boolean jumpBypassEnabled;
    private boolean pendingInitialJump;
    private final LinkedBlockingQueue<Packet<INetHandlerPlayClient>> packetQueue = new LinkedBlockingQueue<>();
    public static TimerUtil slotTimer = new TimerUtil();
    private final CopyOnWriteArrayList<Packet<?>> packets = new CopyOnWriteArrayList<>();
    public Disabler() {
        super("module.exploit.disabler", Category.EXPLOIT, "Disables some anticheats");
    }

    @Override
    public void onDisable() {
        s08PacketTickCount = 0;
        disabling = false;
        airTicks = 0;
        mc.timer.timerSpeed = 1.0f;
        super.onDisable();
    }

    @EventTarget
    public void onMotionEvent(MotionEvent event) {
        setSuffix("Watchdog");
        if (lobbyCheck.isEnabled() && Utils.isLobby()) return;

        if (jumpBypassEnabled &&
                ((disMode.is("SW") && airTicks >= 3) || (disMode.is("BW") && airTicks >= 10))) {

            if (airTicks % 2 == 0) {
                float randomBoost = nextFloat(0.09f, 0.12f); // Z轴添加微小速度

                if (modifyRotationValue.isEnabled()) {
                    // 模拟玩家视角抖动，增加绕过成功率
                    float newYaw = (float)(mc.thePlayer.rotationYaw - 10 + (Math.random() - 0.5) * 3);
                    event.setRotations(newYaw, mc.thePlayer.rotationPitch);
                }

                // 增加 Z 轴移动速度
                event.setZ(event.getZ() + randomBoost);
            }

            // 停止玩家移动（可能是为了绕过检测）
            stop(mc.thePlayer);
        }
    }

    @EventTarget
    public void onMoveEvent(MoveEvent event) {
        if (lobbyCheck.isEnabled() && Utils.isLobby()) return;

        // 如果已启用绕过并满足模式要求的滞空时间，则停止移动
        if (jumpBypassEnabled &&
                ((disMode.is("SW") && airTicks >= 3) || (disMode.is("BW") && airTicks >= 10))) {
            event.setX(0);
            event.setY(0);
            event.setZ(0);
        }
    }

    @EventTarget
    public void onPacketReceiveEvent(PacketReceiveEvent event) {
        //LowHop
        if (event.getPacket() instanceof S08PacketPlayerPosLook && jumpBypassEnabled) {
            disabling  = true;
            s08PacketTickCount++;
            ChatUtil.print("Process");
            // 达到一定 tick 数，完成绕过，重置状态
            if (s08PacketTickCount == 20) {
                jumpBypassEnabled = false;
                mc.thePlayer.jump();
                airTicks = 0;
                s08PacketTickCount = 0;
                NotificationManager.post(NotificationType.INFO, "Disabler", "Disabled Jump check for Watchdog", 2);
                disabling = false;
            }
        }
        //IDK
        if (event.getPacket() instanceof S32PacketConfirmTransaction s32) {
            //System.out.println(((S32PacketConfirmTransaction) event.getPacket()).getActionNumber());
            if (s32.getActionNumber() == 0)
                event.cancel();
        }
        if (event.getPacket() instanceof S2EPacketCloseWindow || event.getPacket() instanceof S2DPacketOpenWindow) {
            reset();
        }
        if (event.getPacket() instanceof S2FPacketSetSlot || event.getPacket() instanceof S30PacketWindowItems) {
            if (!slotTimer.hasTimeElapsed(200)) {
                event.cancel();
                packets.add(event.getPacket());
            }
        }
    }

    @EventTarget
    public void onUpdateEvent(UpdateEvent event) {
        if (mc.thePlayer.onGround) {
            airTicks = 0;
        } else {
            airTicks++;
        }

        // 如果启用了大厅检测，并且当前在大厅，则不启用绕过逻辑
        if (lobbyCheck.isEnabled() && Utils.isLobby()) return;

        // 如果处于待跳跃状态且玩家在地面，则进行跳跃
        if (pendingInitialJump && mc.thePlayer.onGround) {
            mc.thePlayer.jump();  // 触发一次跳跃
            pendingInitialJump = false;
            jumpBypassEnabled = true;
        }
    }

    @EventTarget
    public void onWorldEvent(WorldEvent event) {
        if (lobbyCheck.isEnabled() && Utils.isLobby()) return;

        pendingInitialJump = true;
        jumpBypassEnabled = false;
        s08PacketTickCount = 0;
        airTicks = 0;
    }

    private void reset() {
        while (!packetQueue.isEmpty()){
            packetQueue.poll().processPacket(mc.getNetHandler());
        }
    }

    public static void stopXZ(EntityPlayerSP player) {
        player.motionX = 0.0;
        player.motionZ = 0.0;
    }

    public static void stop(EntityPlayerSP player) {
        stopXZ(player);
        player.motionY = 0.0;
    }

    public float nextFloat(float startInclusive, float endInclusive) {
        return startInclusive == endInclusive || endInclusive - startInclusive <= 0.0f ? startInclusive : (float)((double)startInclusive + (double)(endInclusive - startInclusive) * Math.random());
    }
}

